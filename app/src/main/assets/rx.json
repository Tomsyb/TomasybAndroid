{
  "rxjava": [
    {
      "name": "create",
      "content": "可用于获取一个被观察的对象"
    },
    {
      "name": "map",
      "content": "作用是对上游发送的每一个事件应用一个函数，使得每个事件都得按照指定的函数去变化"
    },
    {
      "name": "zip",
      "content": "合并事件,分别从两个上游事件中各取出一个组合，一个事件只能被使用一次，顺序严格按照事件发送的顺序，最终下游事件收到的是和上游事件最少的数目相同（必须两两配对，多余的舍弃）"
    },
    {
      "name": "concat",
      "content": "对于单一的把两个发射器连接成一个发射器"
    },
    {
      "name": "flatMap",
      "content": "flatMap将一个发送事件的上游Observable变换成多个发送事件的Observables，然后将它们发射的时间合并后放进一个单独的Observable里(无序)"
    },
    {
      "name": "concatMap",
      "content": "和flatMap用法一样只是他有序而已"
    },
    {
      "name": "distinct",
      "content": "去重"
    },
    {
      "name": "filter",
      "content": "过滤不需要的数据"
    },
    {
      "name": "buffer",
      "content": "buffer(count, skip)` 从定义就差不多能看出作用了，将 observable 中的数据按 skip（步长）分成最长不超过 count 的 buffer，然后生成一个 observable"
    },
    {
      "name": "timer",
      "content": "在Rxjava中timer 操作符既可以延迟执行一段逻辑，也可以间隔执行一段逻辑,【注意】但在RxJava 2.x已经过时了，现在用interval操作符来间隔执行,timer和interval都默认执行在一个新线程上"
    },
    {
      "name": "interval",
      "content": "间隔执行操作，默认在新线程,其接受三个参数，分别是第一次发送延迟，间隔时间，时间单位"
    },
    {
      "name": "doOnNext",
      "content": "让订阅者在接手数据之前的操作如保存数据"
    },
    {
      "name": "实际应用--单一网络请求",
      "content": "单一的网络请求,1、通过 Observable.create() 方法，调用 OkHttp 网络请求,2、通过 map 操作符结合 Gson , 将 Response 转换为 bean 类，3、通过 doOnNext() 方法，解析 bean 中的数据，并进行数据库存储等操作，4、调度线程，在子线程进行耗时操作任务，在主线程更新 UI，5、通过 subscribe(),根据请求成功或者失败来更新 UI"
    },
    {
      "name": "实际应用--多个接口同时处理",
      "content": "zip 操作符可以把多个 Observable 的数据接口成一个数据源再发出去"
    }
  ],
  "retrofit": [
    {
      "name": "标题",
      "content": "描述"
    },
    {
      "name": "标题",
      "content": "描述"
    },
    {
      "name": "标题",
      "content": "描述"
    },
    {
      "name": "标题",
      "content": "描述"
    },
    {
      "name": "标题",
      "content": "描述"
    },
    {
      "name": "标题",
      "content": "描述"
    }
  ]
}